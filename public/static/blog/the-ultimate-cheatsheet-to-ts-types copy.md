---
title: "The ultimate cheatsheet to TypeScript's type system."
category: "typescript"
created: 2025-03-20
thumbnail: test-code.webp
summary: "Did you know that TypeScript's type system is Turing complete?"
published: false
---
# A relatable story to get your attention
Your experience with types is probably similar to mine: many years ago, we started learning our first programming language. We started assigning numbers to variables, adding them together, writing strings into the console, reading user input... all the basic stuff. Until one day we had to go further and create our own class: a type just like `int`, `string` or `float`, but that contains the data we need. We created `Person`, `Animal` and all the other clich√© types with 4 fields and 3 methods. Types seemed so easy and convenient. Now, many years later, you've learned the hard way that real life programming is not as easy as creating a class `Person` with `name`, `age` and `country`. Way too many times you needed to create an object that was kind of a `Person`, but wasn't really a `Person`. Maybe you wanted to write a function to modify a `Person`, so this function needs to receive all the fields in `Person`... except the caller may not want to modify every single field, just some of them. So now you need to create a new type called `PersonUpdater` that is the exact same as `Person`, except every field can be `null`. Ok, it's tedious and will make you lose 20 minutes you weren't counting on losing, but you need this partial person type anyway. 3 months later you come back to `Person` and add a new field to it. Everything is fine until, two weeks later, someone tells you that they want to update its new field but they can't, because `PersonUpdater` doesn't have that new field. You forgot about it [continue paragraph here]

# The basics
Before we even begin, there's one thing we need to understand: a typing system can be either structural or nominal. In a nominal type system, a type is a fundamental, non-fungible "entity" that exists in the context of the program. This means that, when you define a class `Dog` with the fields `name`, `age` and `breed`, your program now has a concept of `Dog`: things can be a `Dog` and, if they are, then they have these 3 fields. Now, you can define a class `Cat` with the same fields (`name`, `age` and `breed`), it makes sense, but this doesn't mean that a `Cat` is a `Dog`. If I declare `let whiskers = new Cat("whiskers", 5, "Persian")`, I cannot pass this `whiskers` variable to a function that wants a `Dog`. That'd require a lot of makeup and creativity, and it's not ethical to force a cat to behave like a dog anyway. Languages like C#, Java or C++ work like this: whether something is a `Dog` is defined by whether you explicitly said it is a `Dog`.

In contrast, structural types follow a different philosophy: you don't care about that value's origin, you care about what it can do. This philosophy is often summed up as "if it looks like a duck, it's a duck". In a structural type system, something is a `Dog` if it has the fields `name`, `age` and `breed`. You don't care if that something was explicitly called a `Dog` when it was created, you care that it has the properties you expect dogs to have. If I want to pass `whiskers` to a function expecting a `Dog` here, it's fine - the function doesn't judge `whiskers` by its labels, it judges it by what it can do. TypeScript belongs to this second type, and this means that, every time we write a type in TypeScript, we are not labeling anything, we are just stating what it can do. `whiskers` in TypeScript is not a `Cat`, it just can do the things `Cat`s can do.